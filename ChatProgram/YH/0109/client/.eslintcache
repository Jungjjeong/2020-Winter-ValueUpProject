[{"/Users/just_beaver/Documents/GitHub/valueup/ChatProgram/YH/0109/client/src/index.js":"1","/Users/just_beaver/Documents/GitHub/valueup/ChatProgram/YH/0109/client/src/reportWebVitals.js":"2","/Users/just_beaver/Documents/GitHub/valueup/ChatProgram/YH/0109/client/src/App.js":"3","/Users/just_beaver/Documents/GitHub/valueup/ChatProgram/YH/0109/client/src/routes/Room.js":"4","/Users/just_beaver/Documents/GitHub/valueup/ChatProgram/YH/0109/client/src/routes/CreateRoom.js":"5"},{"size":500,"mtime":1610195312595,"results":"6","hashOfConfig":"7"},{"size":362,"mtime":1610195312597,"results":"8","hashOfConfig":"7"},{"size":1007,"mtime":1610207877151,"results":"9","hashOfConfig":"7"},{"size":8625,"mtime":1610208996336,"results":"10","hashOfConfig":"7"},{"size":388,"mtime":1610200361281,"results":"11","hashOfConfig":"7"},{"filePath":"12","messages":"13","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},"19vt993",{"filePath":"15","messages":"16","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},{"filePath":"17","messages":"18","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},{"filePath":"19","messages":"20","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"21","usedDeprecatedRules":"22"},{"filePath":"23","messages":"24","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},"/Users/just_beaver/Documents/GitHub/valueup/ChatProgram/YH/0109/client/src/index.js",[],["25","26"],"/Users/just_beaver/Documents/GitHub/valueup/ChatProgram/YH/0109/client/src/reportWebVitals.js",[],"/Users/just_beaver/Documents/GitHub/valueup/ChatProgram/YH/0109/client/src/App.js",[],"/Users/just_beaver/Documents/GitHub/valueup/ChatProgram/YH/0109/client/src/routes/Room.js",["27"],"//After creating the room, this code will run the room\n/*import React, {useRef, useEffect} from 'react'\nimport io from 'socket.io-client'\n\nconst Room = (props) => {\n    const userVideo = useRef()\n    const partnerVideo = useRef()\n    const peerRef = useRef()\n    const socketRef = useRef()\n    const otherUser = useRef()\n    const userStream = useRef()\n\n    useEffect(() => {\n        navigator.mediaDevices.getUserMedia({audio: true, video: true}).then(stream => {\n            userVideo.current.srcObject = stream\n            userStream.current = stream\n\n            socketRef.current = io.connect('/')     //connect to the socket.io server\n            socketRef.current.emit('join room', props.match.params.roomID)\n\n            socketRef.current.on('ohter user', userID => {\n                callUser(userID)        //function\n                otherUser.current = userID\n            })\n\n            socketRef.current.on('user joined', userID => {\n                otherUser.current = userID\n            })\n\n            socketRef.current.on('offer', handleReciveCall)\n            socketRef.current.on('answer', handleAnswer)\n            socketRef.current.on('ice-candidate', handleNewICECandidateMsg)\n        })\n    }, [])  //empty array for dependency array\n\n    function callUser(userID){\n        peerRef.current = createPeer(userID)\n        userStream.current.getTracks().forEach(track => peerRef.current.addTrack(track, userStream.current))\n    } \n\n    function createPeer(userID){    //userID: the person who is recieving the call \n        const peer = new RTCPeerConnection({\n            iceServers: [       //figure out a proper path for our peer connection -> be able to conncect with each other\n                {\n                    urls: \"stun:stun.stunprotocol.org\" \n                },\n                {\n                    urls: 'turn:numb.viagenie.ca',\n                    credential: 'muazkh',\n                    username: 'webrtc@live.com'\n                },\n            ]\n        })\n        //attach 3 event handler on peer\n        peer.onicecandidate = handleICECandidateEvent\n        peer.ontrack = handleTrackEvent\n        peer.onnegotiationneeded = () => handleNegotiationNeededEvent(userID)\n\n        return peer     //function callUser() 의 peerRef 로 들어감\n    }\n\n    function handleNegotiationNeededEvent(userID){  //make call\n        peerRef.current.createOffer().then(offer => {\n            return peerRef.current.setLocalDescription(offer)\n        }).then(() => {\n            const payload = {\n                target: userID,\n                caller: socketRef.current.id,\n                sdp: peerRef.current.localDescription\n            }\n            socketRef.current.emit('offer', payload)\n        }).catch(e => console.log(e))\n    }\n\n    function handleReciveCall(incoming){    //recieve call\n        peerRef.current = createPeer();     //call createPeer function\n        const desc = new RTCSessionDescription(incoming.sdp)    //description\n        peerRef.current.setRemoteDescription(desc).then(() => {\n            userStream.current.getTracks().forEach((track => peerRef.current.addTrack(track, userStream.current)))\n        }).then(() => {\n            return peerRef.current.createAnswer()\n        }).then(answer => {\n            return peerRef.current.setLocalDescription(answer)\n        }).then(() => {\n            const payload = {\n                target: incoming.caller,\n                caller: socketRef.current.id,\n                sdp: peerRef.current.localDescription\n            }\n            socketRef.current.emit('answer', payload)\n        })\n    }\n\n    function handleAnswer(message){\n        const desc = new RTCSessionDescription(message.sdp)\n        peerRef.current.setRemoteDescription(desc).catch(e => console.log(e)) \n    }\n\n    function handleICECandidateEvent(e){\n        if(e.candidate){\n            const payload = {\n                target: otherUser.current,\n                candidate: e.candidate\n            }\n            socketRef.current.emit('ice-candidate', payload)\n        }\n    }\n\n    function handleNewICECandidateMsg(incoming){\n        const candidate = new RTCIceCandidate(incoming)\n        peerRef.current.addIceCandidate(candidate).catch(e => console.log(e))\n    }\n\n    function handleTrackEvent(e){\n        partnerVideo.current.srcObject = e.streams[0];\n    }\n\n    return (\n        <div>\n            <video autoPlay ref={userVideo} />\n            <video autoPlay ref={partnerVideo} />\n        </div>\n    )\n}\n\nexport default Room*/\n\nimport React, { useRef, useEffect } from \"react\";\nimport io from \"socket.io-client\";\n\nconst Room = (props) => {\n    const userVideo = useRef();\n    const partnerVideo = useRef();\n    const peerRef = useRef();\n    const socketRef = useRef();\n    const otherUser = useRef();\n    const userStream = useRef();\n\n    useEffect(() => {\n        navigator.mediaDevices.getUserMedia({ audio: true, video: true }).then(stream => {\n            userVideo.current.srcObject = stream;\n            userStream.current = stream;\n\n            socketRef.current = io.connect(\"/\");\n            socketRef.current.emit(\"join room\", props.match.params.roomID);\n\n            socketRef.current.on('other user', userID => {\n                callUser(userID);\n                otherUser.current = userID;\n            });\n\n            socketRef.current.on(\"user joined\", userID => {\n                otherUser.current = userID;\n            });\n\n            socketRef.current.on(\"offer\", handleRecieveCall);\n\n            socketRef.current.on(\"answer\", handleAnswer);\n\n            socketRef.current.on(\"ice-candidate\", handleNewICECandidateMsg);\n        });\n\n    }, []);\n\n    function callUser(userID) {\n        peerRef.current = createPeer(userID);\n        userStream.current.getTracks().forEach(track => peerRef.current.addTrack(track, userStream.current));\n    }\n\n    function createPeer(userID) {\n        const peer = new RTCPeerConnection({\n            iceServers: [\n                {\n                    urls: \"stun:stun.stunprotocol.org\"\n                },\n                {\n                    urls: 'turn:numb.viagenie.ca',\n                    credential: 'muazkh',\n                    username: 'webrtc@live.com'\n                },\n            ]\n        });\n\n        peer.onicecandidate = handleICECandidateEvent;\n        peer.ontrack = handleTrackEvent;\n        peer.onnegotiationneeded = () => handleNegotiationNeededEvent(userID);\n\n        return peer;\n    }\n\n    function handleNegotiationNeededEvent(userID) {\n        peerRef.current.createOffer().then(offer => {\n            return peerRef.current.setLocalDescription(offer);\n        }).then(() => {\n            const payload = {\n                target: userID,\n                caller: socketRef.current.id,\n                sdp: peerRef.current.localDescription\n            };\n            socketRef.current.emit(\"offer\", payload);\n        }).catch(e => console.log(e));\n    }\n\n    function handleRecieveCall(incoming) {\n        peerRef.current = createPeer();\n        const desc = new RTCSessionDescription(incoming.sdp);\n        peerRef.current.setRemoteDescription(desc).then(() => {\n            userStream.current.getTracks().forEach(track => peerRef.current.addTrack(track, userStream.current));\n        }).then(() => {\n            return peerRef.current.createAnswer();\n        }).then(answer => {\n            return peerRef.current.setLocalDescription(answer);\n        }).then(() => {\n            const payload = {\n                target: incoming.caller,\n                caller: socketRef.current.id,\n                sdp: peerRef.current.localDescription\n            }\n            socketRef.current.emit(\"answer\", payload);\n        })\n    }\n\n    function handleAnswer(message) {\n        const desc = new RTCSessionDescription(message.sdp);\n        peerRef.current.setRemoteDescription(desc).catch(e => console.log(e));\n    }\n\n    function handleICECandidateEvent(e) {\n        if (e.candidate) {\n            const payload = {\n                target: otherUser.current,\n                candidate: e.candidate,\n            }\n            socketRef.current.emit(\"ice-candidate\", payload);\n        }\n    }\n\n    function handleNewICECandidateMsg(incoming) {\n        const candidate = new RTCIceCandidate(incoming);\n\n        peerRef.current.addIceCandidate(candidate)\n            .catch(e => console.log(e));\n    }\n\n    function handleTrackEvent(e) {\n        partnerVideo.current.srcObject = e.streams[0];\n    };\n\n    return (\n        <div>\n            <video autoPlay ref={userVideo} />\n            <video autoPlay ref={partnerVideo} />\n        </div>\n    );\n};\n\nexport default Room;",["28","29"],"/Users/just_beaver/Documents/GitHub/valueup/ChatProgram/YH/0109/client/src/routes/CreateRoom.js",[],{"ruleId":"30","replacedBy":"31"},{"ruleId":"32","replacedBy":"33"},{"ruleId":"34","severity":1,"message":"35","line":163,"column":8,"nodeType":"36","endLine":163,"endColumn":10,"suggestions":"37"},{"ruleId":"30","replacedBy":"38"},{"ruleId":"32","replacedBy":"39"},"no-native-reassign",["40"],"no-negated-in-lhs",["41"],"react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'callUser', 'handleRecieveCall', and 'props.match.params.roomID'. Either include them or remove the dependency array.","ArrayExpression",["42"],["40"],["41"],"no-global-assign","no-unsafe-negation",{"desc":"43","fix":"44"},"Update the dependencies array to be: [callUser, handleRecieveCall, props.match.params.roomID]",{"range":"45","text":"46"},[5632,5634],"[callUser, handleRecieveCall, props.match.params.roomID]"]